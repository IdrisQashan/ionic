<!DOCTYPE html>
<html dir="ltr">

<head>
  <meta charset="UTF-8">
  <title>Animation - Basic</title>
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link href="../../../../../css/ionic.bundle.css" rel="stylesheet">
  <link href="../../../../../scripts/testing/styles.css" rel="stylesheet">
  <script src="../../../../../scripts/testing/scripts.js"></script>
  <script nomodule src="../../../../../dist/ionic/ionic.js"></script>
  <script type="module" src="../../../../../dist/ionic/ionic.esm.js"></script>
  <script type="module">
    Element.prototype.animate = null;
    
    import { createAnimation, createGesture } from '../../../../dist/ionic/index.esm.js';
    window.createAnimation = createAnimation;
    window.createGesture = createGesture;
  </script>
  <style>
    .square {
      width: 100px;
      height: 100px;
      background: rgba(0, 0, 255, 0.5);
      text-align: center;
      line-height: 100px;
    }
    
    .track {
      width: 100%;
      max-width: 500px;
      background: rgba(0, 0, 0, 0.2);
    }
  </style>
  </head>

<body
  <ion-app>
    <ion-header>
      <ion-toolbar>
        <ion-title>Animations</ion-title>
      </ion-toolbar>
    </ion-header>
    
    <ion-content class="ion-padding">
      <ion-button class="play" onclick="play()">Play</ion-button>
      <ion-button class="pause" onclick="pause()">Pause</ion-button>
      <ion-button class="stop" onclick="stop()">Stop</ion-button>
      <ion-button class="destroy" onclick="destroy()">Destroy</ion-button>
      
      <br><br>
      
      <div class="square square-a">Hello</div>
      
      <br><br>
      
      <div class="track">
        <div class="square"></div>
      </div>
    </ion-content>
  </ion-app>
  
  <script>
    const squareA = document.querySelector('.square-a');
    let rootAnimation;
      
    const init = () => {
      rootAnimation = createAnimation('root-animation-id');
      
      const animationA = createAnimation('animation-a');
      const animationB = createAnimation('animation-b');
      
      animationA
        .addElement(squareA)
        .fromTo('background', 'rgba(0, 0, 255, 0.5)', 'rgba(0, 0, 255, 1)')
        
      animationB
        .addElement(squareA)
        .fromTo('transform', 'scale(1)', 'scale(0.5)');
      
      rootAnimation
        .iterations(2)
        .duration(500)
        .easing('ease-in-out')
        .direction('alternate')
        .addAnimation([animationA, animationB]);
    }  
    
    const play = () => {
      if (!rootAnimation) { init(); }
      rootAnimation.play();
    };
    
    const pause = () => {
      if (!rootAnimation) { init(); }
      rootAnimation.pause();
    };
    
    const stop = () => {
      if (!rootAnimation) { init(); }
      rootAnimation.stop();
    };
    
    const destroy = () => {
      if (!rootAnimation) { init(); }
      rootAnimation.destroy();
      rootAnimation = undefined;
    };
    
    const initGesture = () => {
      let initialStep = 0;
      let started = false;
      
      const square = document.querySelector('.track .square');
      const MAX_TRANSLATE = document.querySelector('.track').clientWidth - 100;
      
      const animationA = createAnimation()
        .addElement(square)
        .fromTo('transform', 'translateX(0)', `translateX(${MAX_TRANSLATE}px)`);
        
      const animationB = createAnimation()
        .addElement(square)
        .fromTo('opacity', '1' , '0.25');
        
      const rootAnimation = createAnimation()
        .duration(1000)
        .addAnimation([animationA, animationB]);
      
      const gesture = createGesture({
        el: square,
        threshold: 0,
        onMove: ev => onMove(ev),
        onEnd: ev => onEnd(ev)
      })
      
      gesture.enable(true);
      
      const onMove = (ev) => {
        if (!started) {
          rootAnimation.progressStart(false, initialStep);
          started = true;
        }
        
        rootAnimation.progressStep(getStep(ev));
      }
      
      const onEnd = (ev) => {
        if (!started) { return; }
        
        gesture.enable(false);
        
        const step = getStep(ev);
        const shouldComplete = step > 0.5;
      
        rootAnimation
          .progressEnd((shouldComplete) ? 1 : 0, step)
          .onFinish(() => { gesture.enable(true); });  
        
        initialStep = (shouldComplete) ? MAX_TRANSLATE : 0;
        started = false;
      }
      
      const clamp = (min, n, max) => {
        return Math.max(min, Math.min(n, max));
      };
      
      const getStep = (ev) => {
        const delta = initialStep + ev.deltaX;
        return clamp(0, delta / MAX_TRANSLATE, 1);
      }
    }
    
    window.onload = () => {
      setTimeout(() => {
        initGesture()
      }, 250);
    }
    
  </script>
</body>

</html>

